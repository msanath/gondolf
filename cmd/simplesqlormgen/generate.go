package main

import (
	"errors"
	"fmt"
	"go/types"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const bodyTemplate = `
// Code generated by github.com/msanath/gondolf/simplesqlorm. DO NOT EDIT.

package {{.PkgName}}

import (
	"context"

	"github.com/jmoiron/sqlx"
	"github.com/msanath/gondolf/pkg/simplesql"
)

const {{.NonCamelCaseTableName}}TableName = "{{.TableName}}"


type {{.CamelCaseTableName}}TableGetKeys struct {
{{.GetKeysFields}}
}

type {{.CamelCaseTableName}}TableUpdateKey struct {
{{.UpdateKeyFields}}
}

type {{.CamelCaseTableName}}TableUpdateFields struct {
{{.UpdateFields}}
}

type {{.CamelCaseTableName}}TableSelectFilters struct {
{{.SelectFilters}}
}

type {{.CamelCaseTableName}}Table struct {
	simplesql.Database
	tableName string
}

func New{{.CamelCaseTableName}}Table(db simplesql.Database) *{{.CamelCaseTableName}}Table {
	return &{{.CamelCaseTableName}}Table{
		Database:  db,
		tableName: {{.NonCamelCaseTableName}}TableName,
	}
}

func (s *{{.CamelCaseTableName}}Table) Insert(ctx context.Context, execer sqlx.ExecerContext, row {{.StructName}}) error {
	return s.Database.Insert(ctx, execer, s.tableName, row)
}

func (s *{{.CamelCaseTableName}}Table) Get(ctx context.Context, keys {{.CamelCaseTableName}}TableGetKeys) ({{.StructName}}, error) {
	var row {{.StructName}}
	err := s.Database.Get(ctx, s.tableName, keys, &row)
	if err != nil {
		return {{.StructName}}{}, err
	}
	return row, nil
}

func (s *{{.CamelCaseTableName}}Table) Update(
	ctx context.Context, execer sqlx.ExecerContext, updateKey {{.CamelCaseTableName}}TableUpdateKey, updateFields {{.CamelCaseTableName}}TableUpdateFields,
) error {
	return s.Database.Update(ctx, execer, s.tableName, updateKey, updateFields)
}

func (s *{{.CamelCaseTableName}}Table) Delete(ctx context.Context, execer sqlx.ExecerContext, updateKey {{.CamelCaseTableName}}TableUpdateKey) error {
	return s.Database.Delete(ctx, s.tableName, updateKey)
}

func (s *{{.CamelCaseTableName}}Table) List(ctx context.Context, filters {{.CamelCaseTableName}}TableSelectFilters) ([]{{.StructName}}, error) {
	var rows []{{.StructName}}
	err := s.Database.List(ctx, s.tableName, filters, &rows)
	if err != nil {
		return nil, err
	}
	return rows, nil
}
`

type generator struct {
	OutputPath            string
	PkgName               string
	TableName             string
	CamelCaseTableName    string
	NonCamelCaseTableName string
	GetKeysFields         string
	UpdateKeyFields       string
	UpdateFields          string
	SelectFilters         string
	StructName            string
	StructType            *types.Struct
}

func newGenerator(o ORMGenOptions) (*generator, error) {
	pkg, err := getCurrentPackage()
	if err != nil {
		return nil, err
	}

	obj := pkg.Types.Scope().Lookup(o.StructName)
	if obj == nil {
		return nil, fmt.Errorf("type '%s' not found", o.StructName)
	}

	s, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, fmt.Errorf("type '%s' must be a struct", o.StructName)
	}

	getKeys, updateKey, updateFields, selectFilters := parseStructFields(s)
	return &generator{
		PkgName:               pkg.Name,
		TableName:             o.TableName,
		CamelCaseTableName:    snakeToCamel(o.TableName),
		NonCamelCaseTableName: strings.ToLower(o.TableName),
		GetKeysFields:         getKeys,
		UpdateKeyFields:       updateKey,
		UpdateFields:          updateFields,
		SelectFilters:         selectFilters,
		StructName:            o.StructName,
	}, nil
}

func parseStructFields(s *types.Struct) (getKeys, updateKey, updateFields, selectFilters string) {
	getKeys = ""
	updateKey = ""
	updateFields = ""
	selectFilters = ""

	// TODO: This is a bit ugly. Refactor this to be more readable.
	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		fieldName := field.Name()

		tags := reflect.StructTag(s.Tag(i))

		ormTags := tags.Get("orm")
		if ormTags == "" {
			continue
		}

		dbTag := tags.Get("db")
		if dbTag == "" {
			continue
		}

		if strings.Contains(ormTags, "op=get") {
			getKeys += fmt.Sprintf("%s *%s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
		}
		if strings.Contains(ormTags, "soft_delete=true") {
			getKeys += fmt.Sprintf("%s %s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
			updateKey += fmt.Sprintf("%s %s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
			updateFields += fmt.Sprintf("%s *%s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
			selectFilters += fmt.Sprintf("%sEq *%s `db:\"%s:eq\"`\n", fieldName, field.Type().String(), dbTag)
			selectFilters += fmt.Sprintf("%sGte *%s `db:\"%s:gte\"`\n", fieldName, field.Type().String(), dbTag)
		}
		if strings.Contains(ormTags, "key=primary") {
			updateKey += fmt.Sprintf("%s %s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
		}
		if strings.Contains(ormTags, "op_lock=true") {
			updateKey += fmt.Sprintf("%s %s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
		}
		if strings.Contains(ormTags, "op=update") {
			updateFields += fmt.Sprintf("%s *%s `db:\"%s\"`\n", fieldName, field.Type().String(), dbTag)
		}
		if strings.Contains(ormTags, "filter") {
			if strings.Contains(ormTags, "In") {
				selectFilters += fmt.Sprintf("%sIn []%s `db:\"%s:in\"`\n", fieldName, field.Type().String(), dbTag)
			}
			if strings.Contains(ormTags, "NotIn") {
				selectFilters += fmt.Sprintf("%sNotIn []%s `db:\"%s:not_in\"`\n", fieldName, field.Type().String(), dbTag)
			}
			if strings.Contains(ormTags, "Gte") {
				selectFilters += fmt.Sprintf("%sGte *%s `db:\"%s:gte\"`\n", fieldName, field.Type().String(), dbTag)
			}
			if strings.Contains(ormTags, "Lte") {
				selectFilters += fmt.Sprintf("%sLte *%s `db:\"%s:lte\"`\n", fieldName, field.Type().String(), dbTag)
			}
			if strings.Contains(ormTags, "Eq") {
				selectFilters += fmt.Sprintf("%sEq *%s `db:\"%s:eq\"`\n", fieldName, field.Type().String(), dbTag)
			}
		}
	}

	selectFilters += "Limit uint32 `db:\"limit\"`"
	return getKeys, updateKey, updateFields, selectFilters
}

func (g *generator) Generate() error {
	err := executeTemplate("body", bodyTemplate, g.OutputPath, fmt.Sprintf("%s_table_gen.go", g.TableName), g)
	if err != nil {
		return fmt.Errorf("failed to generate file: %w", err)
	}
	return g.tidyGeneratedFile()
}

func getCurrentPackage() (*packages.Package, error) {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedTypesInfo | packages.NeedName | packages.NeedImports | packages.NeedDeps}

	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		return nil, err
	}

	// A directory can have both a regular package and "_test" package in it, and we want the regular one.
	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.Name, "_test") {
			continue
		}
		if len(pkg.Errors) > 0 {
			return nil, pkg.Errors[0]
		}
		return pkg, nil
	}

	return nil, errors.New("no package found")
}

func executeTemplate(templateName, templateStr, path, fileName string, data any) error {
	// Generate the records file
	filePath := filepath.Join(path, fileName)
	// Check if the file already exists. If so delete it and recreate it.
	if _, err := os.Stat(filePath); err == nil {
		if err := os.Remove(filePath); err != nil {
			return fmt.Errorf("failed to remove existing record file: %w", err)
		}
	}

	// Create the record file
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create record file: %w", err)
	}
	defer f.Close()

	// Execute the template
	t := template.Must(template.New(templateName).Parse(templateStr))
	err = t.Execute(f, data)
	if err != nil {
		return fmt.Errorf("failed to execute record template: %w", err)
	}
	return nil
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			// Capitalize the first letter, keep the rest as is
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func (g *generator) tidyGeneratedFile() error {
	tidyCmd := exec.Command("go", "mod", "tidy")
	tidyCmd.Dir = g.OutputPath // Set the working directory to the destination path
	tidyCmd.Stdout = os.Stdout
	tidyCmd.Stderr = os.Stderr
	if err := tidyCmd.Run(); err != nil {
		fmt.Println("Error running 'go mod tidy':", err)
		return err
	}

	fmtCmd := exec.Command("go", "fmt", "./...")
	fmtCmd.Dir = g.OutputPath // Set the working directory to the destination path
	fmtCmd.Stdout = os.Stdout
	fmtCmd.Stderr = os.Stderr
	if err := fmtCmd.Run(); err != nil {
		fmt.Println("Error running 'go fmt':", err)
		return err
	}

	return nil
}

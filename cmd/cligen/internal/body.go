package internal

import (
	"go/types"
	"reflect"
	"strings"
)

// bodyTemplate is the template for generating get statements.
const bodyTemplate = `
// Code generated by msanath/gondolf/cligen. DO NOT EDIT.

package {{.PkgName}}

{{- range .Imports }}

import "{{.}}"
{{- end}}

const (
	{{- range .ColumnAttrs }}
	{{.ColumnTagName}} = "{{.ColumnTagValue}}"
	{{- end}}
)

func Get{{.MainStructName}}ColumnTags() []string {
	return []string{
		{{- range .ColumnAttrs }}
		{{.ColumnTagName}},
		{{- end}}
	}
}

func Validate{{.MainStructName}}ColumnTags(tags []string) error {
	validTags := Get{{.MainStructName}}ColumnTags()
	for _, tag := range tags {
		if !slices.Contains(validTags, tag) {
			return fmt.Errorf("column tag '%s' not found. Valid tags are %v", tag, validTags)
		}
	}
	return nil
}

func (n *{{.MainStructName}}) GetDisplayFieldFromColumnTag(columnTag string) (printer.DisplayField, error) {
	switch columnTag {
	{{- range .ColumnAttrs }}
	case {{.ColumnTagName}}:
		return n.{{.DerivedAttributeGetter}}(), nil
	{{- end}}
	}
	return printer.DisplayField{}, fmt.Errorf("column tag '%s' not found. Valid tags are %v", columnTag, Get{{.MainStructName}}ColumnTags())
}

{{- range .IntAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strconv.Itoa(n.{{.AttributeName}})
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .BoolAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strconv.FormatBool(n.{{.AttributeName}})
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .StrArrayAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {

	// Sort the array to make the output deterministic
	sort.Strings(n.{{.AttributeName}})
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strings.Join(n.{{.AttributeName}}, "\n")
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .StrAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := n.{{.AttributeName}}
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .TimeDurationAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := duration.HumanDuration(n.{{.AttributeName}})
			return str
		},
	}
}
{{- end}}

{{- range .TimeTimeAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := n.{{.AttributeName}}.String()
			curTime := time.Now().UTC()
			agoTime := curTime.Sub(n.{{.AttributeName}})
			str += " (" + duration.HumanDuration(agoTime) + " ago)"
			return str
		},
	}
}
{{- end}}
`

type body struct {
	PkgName           string
	MainStructName    string
	Imports           []string
	IntAttrs          []attributeParams
	BoolAttrs         []attributeParams
	StrAttrs          []attributeParams
	StrArrayAttrs     []attributeParams
	TimeDurationAttrs []attributeParams
	TimeTimeAttrs     []attributeParams
	ColumnAttrs       []attributeParams
}

type attributeParams struct {
	StructName             string
	DisplayName            string
	JSONTag                string
	ColumnTagValue         string
	ColumnTagName          string
	Type                   types.Type
	AttributeName          string
	RedTexts               []string
	GreenTexts             []string
	YellowTexts            []string
	DerivedAttributeGetter string
}

func (g *Generator) getBody() (body, error) {
	imports := []string{
		"github.com/msanath/gondolf/pkg/printer",
		"github.com/msanath/gondolf/pkg/duration",
		"strings",
	}
	strAttrs := []attributeParams{}
	columnAttrs := []attributeParams{}
	intAttrs := []attributeParams{}
	boolAttrs := []attributeParams{}
	strArrayAttrs := []attributeParams{}
	timeDurationAttrs := []attributeParams{}
	timeTimeAttrs := []attributeParams{}

	s := g.structType
	attrs := getAttrs(s, g.structName, []string{})

	alreadyAdded := map[string]bool{}

	for _, attr := range attrs {
		if alreadyAdded[attr.StructName+attr.AttributeName] {
			continue
		}
		alreadyAdded[attr.StructName+attr.AttributeName] = true

		if attr.ColumnTagValue != "" {
			columnAttrs = append(columnAttrs, attr)
		}

		if attr.DisplayName != "" {
			switch {
			case isTimeDuration(attr.Type):
				timeDurationAttrs = append(timeDurationAttrs, attr)
			case isTimeTime(attr.Type):
				timeTimeAttrs = append(timeTimeAttrs, attr)
			case isNumber(attr.Type):
				intAttrs = append(intAttrs, attr)
			case isBool(attr.Type):
				boolAttrs = append(boolAttrs, attr)
			case isStringArray(attr.Type):
				strArrayAttrs = append(strArrayAttrs, attr)
			case isString(attr.Type):
				strAttrs = append(strAttrs, attr)
			default:
				panic("unsupported type" + attr.Type.String())
			}
		}

	}

	return body{
		PkgName:           g.pkgName,
		MainStructName:    g.structName,
		Imports:           imports,
		StrAttrs:          strAttrs,
		StrArrayAttrs:     strArrayAttrs,
		BoolAttrs:         boolAttrs,
		ColumnAttrs:       columnAttrs,
		IntAttrs:          intAttrs,
		TimeDurationAttrs: timeDurationAttrs,
		TimeTimeAttrs:     timeTimeAttrs,
	}, nil
}

func getAttrs(s *types.Struct, structName string, parents []string) []attributeParams {
	var attrs []attributeParams
	for i := 0; i < s.NumFields(); i++ {
		f := s.Field(i)
		tags := reflect.StructTag(s.Tag(i))
		if tags.Get("doNotGen") == "true" {
			continue
		}

		// If the field is a nested struct (or pointer/slice of one), process it recursively.
		if nested, ok := tryExtractNestedAttrs(f, parents); ok {
			attrs = append(attrs, nested...)
			continue
		}

		// Skip non-exported fields.
		if !f.Exported() {
			continue
		}

		// Process the field’s tags.
		jsonTag := strings.Split(tags.Get("json"), ",")[0]

		attr := attributeParams{
			StructName:             structName,
			AttributeName:          f.Name(),
			JSONTag:                jsonTag,
			Type:                   f.Type(),
			ColumnTagValue:         tags.Get("columnTag"),
			ColumnTagName:          "Column" + toCamelCase(tags.Get("columnTag")),
			DisplayName:            tags.Get("displayName"),
			RedTexts:               getTagValues(tags, "redTexts"),
			GreenTexts:             getTagValues(tags, "greenTexts"),
			YellowTexts:            getTagValues(tags, "yellowTexts"),
			DerivedAttributeGetter: makeGetter(f.Name(), parents),
		}
		attrs = append(attrs, attr)
	}
	return attrs
}

// tryExtractNestedAttrs checks whether f’s type is a struct (or pointer/slice thereof)
// and, if so, calls getAttrs recursively.
func tryExtractNestedAttrs(f *types.Var, parents []string) ([]attributeParams, bool) {
	typ := f.Type()
	// Skip time.Time even though it is a struct.
	if typ.String() == "time.Time" {
		return nil, false
	}

	switch t := typ.Underlying().(type) {
	case *types.Struct:
		structName := lastPart(typ.String())
		return getAttrs(t, structName, append(parents, f.Name())), true

	case *types.Pointer:
		if st, ok := t.Elem().Underlying().(*types.Struct); ok {
			structName := lastPart(t.Elem().String())
			return getAttrs(st, structName, append(parents, f.Name())), true
		}

	case *types.Slice:
		switch elem := t.Elem().Underlying().(type) {
		case *types.Struct:
			structName := lastPart(t.Elem().String())
			// Note: for a slice of struct, we append the struct name.
			return getAttrs(elem, structName, append(parents, structName)), true
		case *types.Pointer:
			if st, ok := elem.Elem().Underlying().(*types.Struct); ok {
				structName := lastPart(elem.Elem().String())
				return getAttrs(st, structName, append(parents, f.Name())), true
			}
		}
	}
	return nil, false
}

// lastPart returns the substring after the last dot.
// For example, "*middle-earth/gondolf/cligen.DisruptionSummary" becomes "DisruptionSummary".
func lastPart(s string) string {
	if idx := strings.LastIndex(s, "."); idx != -1 && idx < len(s)-1 {
		return s[idx+1:]
	}
	return s
}

// getTagValues splits a comma-separated tag value into a slice.
// If the tag isn’t present or empty, it returns nil.
func getTagValues(tags reflect.StructTag, key string) []string {
	if val, ok := tags.Lookup(key); ok && val != "" {
		return strings.Split(val, ",")
	}
	return nil
}

// makeGetter builds the derived attribute getter.
// If there are any parent names, they are joined with dots.
func makeGetter(name string, parents []string) string {
	getter := "Get" + name
	if len(parents) > 0 {
		getter = strings.Join(parents, ".") + "." + getter
	}
	return getter
}

func toCamelCase(input string) string {
	isToUpper := false
	output := ""
	for i, v := range input {
		if v == '_' {
			isToUpper = true
		} else {
			if isToUpper || i == 0 {
				output += strings.ToUpper(string(v))
				isToUpper = false
			} else {
				output += string(v)
			}
		}
	}
	return output
}

func isNumber(f types.Type) bool {
	return strings.Contains(f.String(), "int") || strings.Contains(f.String(), "float")
}

func isBool(f types.Type) bool {
	return strings.Contains(f.String(), "bool")
}

func isStringArray(f types.Type) bool {
	return strings.Contains(f.String(), "[]string")
}

func isString(f types.Type) bool {
	return strings.Contains(f.String(), "string")
}

func isTimeDuration(f types.Type) bool {
	return strings.Contains(f.String(), "time.Duration")
}

func isTimeTime(f types.Type) bool {
	return strings.Contains(f.String(), "time.Time")
}

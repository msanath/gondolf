package internal

import (
	"go/types"
	"reflect"
	"strings"
)

// bodyTemplate is the template for generating get statements.
const bodyTemplate = `
// Code generated by msanath/gondolf/cligen. DO NOT EDIT.

package {{.PkgName}}

{{- range .Imports }}

import "{{.}}"
{{- end}}

const (
	{{- range .ColumnAttrs }}
	{{.ColumnTagName}} = "{{.ColumnTagValue}}"
	{{- end}}
)

func Get{{.MainStructName}}ColumnTags() []string {
	return []string{
		{{- range .ColumnAttrs }}
		{{.ColumnTagName}},
		{{- end}}
	}
}

func Validate{{.MainStructName}}ColumnTags(tags []string) error {
	validTags := Get{{.MainStructName}}ColumnTags()
	for _, tag := range tags {
		if !slices.Contains(validTags, tag) {
			return fmt.Errorf("column tag '%s' not found. Valid tags are %v", tag, validTags)
		}
	}
	return nil
}

func (n *{{.MainStructName}}) GetDisplayFieldFromColumnTag(columnTag string) (printer.DisplayField, error) {
	switch columnTag {
	{{- range .ColumnAttrs }}
	case {{.ColumnTagName}}:
		return n.{{.DerivedAttributeGetter}}(), nil
	{{- end}}
	}
	return printer.DisplayField{}, fmt.Errorf("column tag '%s' not found. Valid tags are %v", columnTag, Get{{.MainStructName}}ColumnTags())
}

{{- range .IntAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strconv.Itoa(n.{{.AttributeName}})
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .BoolAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strconv.FormatBool(n.{{.AttributeName}})
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .StrArrayAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {

	// Sort the array to make the output deterministic
	sort.Strings(n.{{.AttributeName}})
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := strings.Join(n.{{.AttributeName}}, "\n")
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if slices.Contains(n.{{.AttributeName}}, "{{.}}") {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .StrAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := n.{{.AttributeName}}
			{{- if .RedTexts }}
				{{- range .RedTexts }}
				if str == "{{.}}" {
					return printer.RedText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .GreenTexts }}
				{{- range .GreenTexts }}
				if str == "{{.}}" {
					return printer.GreenText(str)
				}
				{{- end}}
			{{- end}}
			{{- if .YellowTexts }}
				{{- range .YellowTexts }}
				if str == "{{.}}" {
					return printer.YellowText(str)
				}
				{{- end}}
			{{- end}}
			return str
		},
	}
}
{{- end}}

{{- range .TimeDurationAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := duration.HumanDuration(n.{{.AttributeName}})
			return str
		},
	}
}
{{- end}}

{{- range .TimeTimeAttrs }}

func (n *{{.StructName}}) Get{{.AttributeName}}() printer.DisplayField {
	return printer.DisplayField{
		DisplayName: "{{.DisplayName}}",
		ColumnTag: "{{.ColumnTagValue}}",
		Value: func() string {
			str := n.{{.AttributeName}}.String()
			curTime := time.Now().UTC()
			agoTime := curTime.Sub(n.{{.AttributeName}})
			str += " (" + duration.HumanDuration(agoTime) + " ago)"
			return str
		},
	}
}
{{- end}}
`

type body struct {
	PkgName           string
	MainStructName    string
	Imports           []string
	IntAttrs          []attributeParams
	BoolAttrs         []attributeParams
	StrAttrs          []attributeParams
	StrArrayAttrs     []attributeParams
	TimeDurationAttrs []attributeParams
	TimeTimeAttrs     []attributeParams
	ColumnAttrs       []attributeParams
}

type attributeParams struct {
	StructName             string
	DisplayName            string
	JSONTag                string
	ColumnTagValue         string
	ColumnTagName          string
	Type                   types.Type
	AttributeName          string
	RedTexts               []string
	GreenTexts             []string
	YellowTexts            []string
	DerivedAttributeGetter string
}

func (g *Generator) getBody() (body, error) {
	imports := []string{
		"github.com/msanath/gondolf/pkg/printer",
		"github.com/msanath/gondolf/pkg/duration",
		"strings",
	}
	strAttrs := []attributeParams{}
	columnAttrs := []attributeParams{}
	intAttrs := []attributeParams{}
	boolAttrs := []attributeParams{}
	strArrayAttrs := []attributeParams{}
	timeDurationAttrs := []attributeParams{}
	timeTimeAttrs := []attributeParams{}

	s := g.structType
	attrs := getAttrs(s, g.structName, []string{})

	alreadyAdded := map[string]bool{}

	for _, attr := range attrs {
		if alreadyAdded[attr.StructName+attr.AttributeName] {
			continue
		}
		alreadyAdded[attr.StructName+attr.AttributeName] = true

		if attr.ColumnTagValue != "" {
			columnAttrs = append(columnAttrs, attr)
		}

		if attr.DisplayName != "" {
			switch {
			case isTimeDuration(attr.Type):
				timeDurationAttrs = append(timeDurationAttrs, attr)
			case isTimeTime(attr.Type):
				timeTimeAttrs = append(timeTimeAttrs, attr)
			case isNumber(attr.Type):
				intAttrs = append(intAttrs, attr)
			case isBool(attr.Type):
				boolAttrs = append(boolAttrs, attr)
			case isStringArray(attr.Type):
				strArrayAttrs = append(strArrayAttrs, attr)
			case isString(attr.Type):
				strAttrs = append(strAttrs, attr)
			default:
				panic("unsupported type" + attr.Type.String())
			}
		}

	}

	return body{
		PkgName:           g.pkgName,
		MainStructName:    g.structName,
		Imports:           imports,
		StrAttrs:          strAttrs,
		StrArrayAttrs:     strArrayAttrs,
		BoolAttrs:         boolAttrs,
		ColumnAttrs:       columnAttrs,
		IntAttrs:          intAttrs,
		TimeDurationAttrs: timeDurationAttrs,
		TimeTimeAttrs:     timeTimeAttrs,
	}, nil
}

func getAttrs(s *types.Struct, structName string, parents []string) []attributeParams {
	attrs := []attributeParams{}
	for i := 0; i < s.NumFields(); i++ {
		f := s.Field(i)
		name := f.Name()
		tags := reflect.StructTag(s.Tag(i))
		if tags.Get("doNotGen") == "true" {
			continue
		}

		if f.Type().String() != "time.Time" {
			_, ok := f.Type().Underlying().(*types.Struct)
			if ok {
				structName := f.Type().String()
				// *middle-earth/gondolf/cligen.DisruptionSummary
				// Get the last part of the string
				structName = structName[strings.LastIndex(structName, ".")+1:]
				subAttrs := getAttrs(f.Type().Underlying().(*types.Struct), structName, append(parents, name))
				attrs = append(attrs, subAttrs...)
				continue
			}
			// check if this is an array of structs and get the attributes of the struct
			_, ok = f.Type().Underlying().(*types.Slice)
			if ok {
				sliceType := f.Type().Underlying().(*types.Slice)
				_, ok = sliceType.Elem().Underlying().(*types.Struct)
				if ok {
					structName := sliceType.Elem().String()
					// *middle-earth/gondolf/cligen.DisruptionSummary
					// Get the last part of the string
					structName = structName[strings.LastIndex(structName, ".")+1:]
					subAttrs := getAttrs(sliceType.Elem().Underlying().(*types.Struct), structName, append(parents, structName))
					attrs = append(attrs, subAttrs...)
					continue
				}
			}
		}

		if !f.Exported() {
			// Skip private fields
			continue
		}

		splitTags := strings.Split(tags.Get("json"), ",")
		jsonTag := splitTags[0]

		attributeName := name

		var redTexts []string
		redTextsVal, ok := tags.Lookup("redTexts")
		if ok {
			redTexts = strings.Split(redTextsVal, ",")
		}

		var greenTexts []string
		greenTextsVal, ok := tags.Lookup("greenTexts")
		if ok {
			greenTexts = strings.Split(greenTextsVal, ",")
		}

		var yellowTexts []string
		yellowTextsVal, ok := tags.Lookup("yellowTexts")
		if ok {
			yellowTexts = strings.Split(yellowTextsVal, ",")
		}

		derivedAttributeGetter := "Get" + name
		if len(parents) > 0 {
			derivedAttributeGetter = strings.Join(parents, ".") + "." + derivedAttributeGetter
		}

		attr := attributeParams{
			StructName:             structName,
			AttributeName:          attributeName,
			JSONTag:                jsonTag,
			Type:                   f.Type(),
			ColumnTagValue:         tags.Get("columnTag"),
			ColumnTagName:          "Column" + toCamelCase(tags.Get("columnTag")),
			DisplayName:            tags.Get("displayName"),
			RedTexts:               redTexts,
			GreenTexts:             greenTexts,
			YellowTexts:            yellowTexts,
			DerivedAttributeGetter: derivedAttributeGetter,
		}
		attrs = append(attrs, attr)
	}
	return attrs
}

func toCamelCase(input string) string {
	isToUpper := false
	output := ""
	for i, v := range input {
		if v == '_' {
			isToUpper = true
		} else {
			if isToUpper || i == 0 {
				output += strings.ToUpper(string(v))
				isToUpper = false
			} else {
				output += string(v)
			}
		}
	}
	return output
}

func isNumber(f types.Type) bool {
	return strings.Contains(f.String(), "int") || strings.Contains(f.String(), "float")
}

func isBool(f types.Type) bool {
	return strings.Contains(f.String(), "bool")
}

func isStringArray(f types.Type) bool {
	return strings.Contains(f.String(), "[]string")
}

func isString(f types.Type) bool {
	return strings.Contains(f.String(), "string")
}

func isTimeDuration(f types.Type) bool {
	return strings.Contains(f.String(), "time.Duration")
}

func isTimeTime(f types.Type) bool {
	return strings.Contains(f.String(), "time.Time")
}

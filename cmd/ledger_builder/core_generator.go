package main

import (
	"fmt"
	"os"
	"path/filepath"
)

const errorsFile = `
// Code generated by ledger-builder. DO NOT EDIT.

package errors

import "fmt"

type RequestError string

const (
	// RequestError_INVALID_REQUEST is returned when the request is invalid.
	RequestErrorInvalidRequest RequestError = "RequestError_INVALID_REQUEST"

	// RequestError_ILLEGAL_REQUEST is returned when the requestor is not authenticated to perform the request.
	RequestErrorIllegalRequest RequestError = "RequestError_ILLEGAL_REQUEST"

	// RequestError_FORBIDDEN is returned when the requestor is not authorized to perform the request.
	RequestErrorForbidden RequestError = "RequestError_FORBIDDEN"

	// RequestError_INTERNAL is returned when an internal error occurs.
	RequestErrorInternal RequestError = "RequestError_INTERNAL"
)

type RequestValidationError struct {
	Code    RequestError
	Message string
}

func (e RequestValidationError) Error() string {
	return e.Message
}

type RepositoryError string

const (
	RepositoryErrorRecordNotFound       RepositoryError = "RepositoryError_RECORD_NOT_FOUND"
	RepositoryErrorRecordInsertConflict RepositoryError = "RepositoryError_RECORD_INSERT_CONFLICT"
	RepositoryErrorInvalidRecord        RepositoryError = "RepositoryError_INVALID_RECORD"
	RepositoryErrorInternal             RepositoryError = "RepositoryError_INTERNAL"
)

type StorageError struct {
	Code    RepositoryError
	Message string
}

func (e StorageError) Error() string {
	return fmt.Sprintf("Error %s, message: %s", e.Code, e.Message)
}

func NewStorageError(code RepositoryError, message string) StorageError {
	return StorageError{Code: code, Message: message}
}
`

const coreRecords = `
// Code generated by ledger-builder. DO NOT EDIT.

package core

// Metadata is a representation of the metadata of any given resource managed by
// the API server. Clients should not set the fields of Metadata directly.
type Metadata struct {
	ID      string // ID is the unique identifier of the resource.
	Version uint64 // Version is the version of the resource as it is known to the Ledger.

	// IsDeleted indicates whether the resource has been marked as deleted.
	// If true, the resource has been soft-deleted but may still exist in the system.
	// No further operations can be performed on the resource.
	IsDeleted bool
}

type Filters struct {
	IDIn       []string // IN condition
	NameIn     []string // IN condition
	VersionGte *uint64  // Greater than or equal condition
	VersionLte *uint64  // Less than or equal condition
	VersionEq  *uint64  // Equal condition
	StateIn    []string // IN condition
	StateNotIn []string // NOT IN condition

	IncludeDeleted bool
	Limit          uint32
}

type Status struct {
	State   string // State is the discrete condition of the resource.
	Message string // Message is a human-readable description of the resource's state.
}
`

func (o generateOptions) generateCoreComponents() error {

	corePath := filepath.Join(o.DestinationPath, "core")
	fmt.Println("Generating core components at ", corePath)
	// Create destination path if it doesn't exist
	err := os.MkdirAll(corePath, 0755)
	if err != nil {
		return fmt.Errorf("failed to create destination path: %w", err)
	}

	_, err = os.Stat(filepath.Join(corePath, "core.go"))
	if err == nil {
		fmt.Println("... core.go already exists. Skipping")
	} else {
		fmt.Println("... creating core.go")
		err = executeTemplate("corefile", coreRecords, corePath, "core.go", o)
		if err != nil {
			return fmt.Errorf("failed to generate record file: %w", err)
		}
	}

	_, err = os.Stat(filepath.Join(corePath, "errors"))
	if err == nil {
	} else {
		errorsPath := filepath.Join(corePath, "errors")
		// Create destination path if it doesn't exist
		err = os.MkdirAll(errorsPath, 0755)
		if err != nil {
			return fmt.Errorf("failed to create destination path: %w", err)
		}

		fmt.Println("... creating errors.go")
		err = executeTemplate("errorsfile", errorsFile, errorsPath, "errors.go", o)
		if err != nil {
			return fmt.Errorf("failed to generate errors file: %w", err)
		}
	}

	return nil
}

package internal

import (
	"fmt"
	"os"
	"path/filepath"
)

const errorsFile = `
// Code generated by ledger-builder. DO NOT EDIT.

package errors

type ErrLedger string

const (
	// ErrRequestInvalid is returned when the request is invalid.
	ErrRequestInvalid ErrLedger = "RequestError_INVALID_REQUEST"

	// ErrRequestIllegal is returned when the requestor is not authenticated to perform the request.
	ErrRequestIllegal ErrLedger = "RequestError_ILLEGAL_REQUEST"

	// ErrRequestForbidden is returned when the requestor is not authorized to perform the request.
	ErrRequestForbidden ErrLedger = "RequestError_FORBIDDEN"

	// ErrInternal is returned when an internal error occurs.
	ErrInternal ErrLedger = "RequestError_INTERNAL"

	// ErrRecordNotFound is returned when a requested record is not found in the repository.
	ErrRecordNotFound ErrLedger = "RepositoryError_RECORD_NOT_FOUND"

	// ErrRecordInsertConflict is returned when there is a conflict while inserting a record into the repository, such as a duplicate entry.
	ErrRecordInsertConflict ErrLedger = "RepositoryError_RECORD_INSERT_CONFLICT"

	// ErrRepositoryInternal is returned when an internal error occurs within the repository, such as a database failure.
	ErrRepositoryInternal ErrLedger = "RepositoryError_INTERNAL"
)

type LedgerError struct {
	Code    ErrLedger
	Message string
}

func (e LedgerError) Error() string {
	return e.Message
}

func NewLedgerError(code ErrLedger, message string) LedgerError {
	return LedgerError{Code: code, Message: message}
}

// IsLedgerError returns true if the error is of type LedgerError.
func IsLedgerError(err error) bool {
	_, ok := err.(LedgerError)
	return ok
}

// AsLedgerError returns the error as a LedgerError.
func AsLedgerError(err error) LedgerError {
	return err.(LedgerError)
}
`

const coreRecords = `
// Code generated by ledger-builder. DO NOT EDIT.

package core

// Metadata is a representation of the metadata of any given resource managed by
// the API server. Clients should not set the fields of Metadata directly.
type Metadata struct {
	ID      string // ID is the unique identifier of the resource.
	Version uint64 // Version is the version of the resource as it is known to the Ledger.

	// IsDeleted indicates whether the resource has been marked as deleted.
	// If true, the resource has been soft-deleted but may still exist in the system.
	// No further operations can be performed on the resource.
	IsDeleted bool
}
`

func (o GenerateOptions) generateCoreComponents() error {
	ledgerPath := filepath.Join(o.DestinationPath, "internal", "ledger")
	ledgerCorePath := filepath.Join(ledgerPath, "core")
	ledgerErrorsPath := filepath.Join(ledgerPath, "errors")

	fmt.Println("Generating core models at ", ledgerCorePath)
	err := os.MkdirAll(ledgerCorePath, 0755)
	if err != nil {
		return fmt.Errorf("failed to create ledger core path: %w", err)
	}
	_, err = os.Stat(filepath.Join(ledgerCorePath, "models.go"))
	if err == nil {
		fmt.Println("... models.go already exists. Skipping")
	} else {
		fmt.Println("... creating models.go")
		err = executeTemplate("corefile", coreRecords, ledgerCorePath, "models.go", o)
		if err != nil {
			return fmt.Errorf("failed to generate record file: %w", err)
		}
	}

	fmt.Println("Generating errors at ", ledgerErrorsPath)
	err = os.MkdirAll(ledgerErrorsPath, 0755)
	if err != nil {
		return fmt.Errorf("failed to create destination path: %w", err)
	}
	_, err = os.Stat(filepath.Join(ledgerErrorsPath, "errors.go"))
	if err == nil {
		fmt.Println("... errors.go already exists. Skipping")
	} else {
		fmt.Println("... creating errors.go")
		err = executeTemplate("errorsfile", errorsFile, ledgerErrorsPath, "errors.go", o)
		if err != nil {
			return fmt.Errorf("failed to generate errors file: %w", err)
		}
	}

	return nil
}
